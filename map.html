<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxy Instance Map - Geographic Distribution</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 1rem;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header-section {
      background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
      color: white;
      padding: 2rem;
    }

    .header-title {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 2rem;
    }

    .title-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .galaxy-logo {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: white;
      padding: 8px;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin: 0;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .subtitle {
      font-size: 1.1rem;
      margin-top: 0.5rem;
      opacity: 0.9;
      font-weight: 300;
    }

    .summary-stats {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }

    .stat-box {
      background: rgba(255, 255, 255, 0.15);
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      min-width: 120px;
      backdrop-filter: blur(10px);
    }

    .stat-number {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
    }

    .stat-box div:last-child {
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .search-container {
      margin-top: 1.5rem;
    }

    .search-input {
      width: 100%;
      padding: 0.75rem 1rem;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      backdrop-filter: blur(10px);
    }

    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.7);
    }

    .search-input:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.15);
    }

    .controls-section {
      padding: 1.5rem 2rem;
      background: #f8f9fa;
      border-bottom: 1px solid #e9ecef;
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .view-toggle {
      display: flex;
      background: white;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .view-toggle button {
      padding: 0.5rem 1rem;
      border: none;
      background: white;
      color: #666;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .view-toggle button.active {
      background: #2196f3;
      color: white;
    }

    .view-toggle button:hover:not(.active) {
      background: #f5f5f5;
    }

    button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    .refresh-btn {
      background: #2196f3;
      color: white;
    }

    .export-btn {
      background: #4caf50;
      color: white;
    }

    .map-container {
      position: relative;
      height: 600px;
      background: #f0f8ff;
      margin: 2rem;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #world-map {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #world-map:active {
      cursor: grabbing;
    }

    .country {
      fill: #e8f5e8;
      stroke: #b8d8b8;
      stroke-width: 0.5px;
      cursor: pointer;
      transition: fill 0.2s;
    }

    .country:hover {
      fill: #d4f1d4 !important;
      stroke: #4caf50;
      stroke-width: 1px;
    }

    .ocean {
      fill: #e3f2fd;
      opacity: 0.6;
    }

    .table-container {
      margin: 2rem;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .table-header {
      background: #2c3e50;
      color: white;
      padding: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
    }

    th, td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid #e9ecef;
    }

    th {
      background: #f8f9fa;
      font-weight: 600;
      color: #2c3e50;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    tr:hover {
      background: #f8f9fa;
    }

    .status-icon {
      font-size: 1.2rem;
      margin-right: 0.5rem;
    }

    .tier-icon {
      font-size: 1rem;
      margin-right: 0.5rem;
    }

    .server-name {
      font-weight: 500;
      color: #2c3e50;
    }

    .server-url {
      font-size: 0.85rem;
      color: #666;
      text-decoration: none;
    }

    .server-url:hover {
      color: #2196f3;
    }

    .location-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .country-flag {
      font-size: 1.2rem;
      margin-right: 0.5rem;
    }

    .coordinates {
      font-size: 0.8rem;
      color: #666;
      font-family: monospace;
    }

    .loading-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #2196f3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.5rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status-indicator {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .status-online {
      background: #e8f5e8;
      color: #2e7d32;
    }

    .status-issues {
      background: #fff3e0;
      color: #f57c00;
    }

    .status-offline {
      background: #ffebee;
      color: #c62828;
    }

    .no-results {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }

    #status {
      margin: 2rem;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
    }

    .status-loading {
      background: #e3f2fd;
      border: 1px solid #2196f3;
      color: #1976d2;
    }

    .status-error {
      background: #ffebee;
      border: 1px solid #f44336;
      color: #c62828;
    }

    .status-success {
      background: #e8f5e8;
      border: 1px solid #4caf50;
      color: #2e7d32;
    }

    .navigation-links {
      margin: 2rem;
      text-align: center;
      display: flex;
      justify-content: center;
      gap: 2rem;
      flex-wrap: wrap;
    }

    .navigation-links a {
      color: #2196f3;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
      transition: color 0.2s;
    }

    .navigation-links a:hover {
      color: #1976d2;
    }

    .map-marker {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
      cursor: pointer;
      transition: all 0.2s;
      stroke-width: 2;
      stroke: white;
    }

    .map-marker:hover {
      transform: scale(1.5);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
    }

    .map-marker.tier-1 {
      fill: #4caf50; /* Global Instance */
    }

    .map-marker.tier-2 {
      fill: #ff9800; /* National Instance */
    }

    .map-marker.tier-3 {
      fill: #2196f3; /* Subdomain */
    }

    .map-marker.tier-4 {
      fill: #9c27b0; /* Institutional */
    }

    .map-marker.tier-5 {
      fill: #607d8b; /* Integrated Platform */
    }

    .map-marker.tier-6 {
      fill: #795548; /* Development Instance */
    }

    .map-marker.tier-0,
    .map-marker.tier-unknown {
      fill: #999; /* Unknown tier */
    }

    .marker-cluster {
      cursor: pointer;
      transition: all 0.2s;
    }

    .marker-cluster:hover {
      transform: scale(1.1);
      opacity: 1 !important;
    }

    .cluster-text {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .cluster-group {
      cursor: pointer;
    }

    .cluster-tooltip {
      border: 1px solid #444;
    }

    .cluster-tooltip::-webkit-scrollbar {
      width: 6px;
    }

    .cluster-tooltip::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    .cluster-tooltip::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }

    .cluster-tooltip::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    .country {
      cursor: pointer;
      transition: fill 0.2s;
    }

    .country:hover {
      fill: #d4f1d4 !important;
      stroke: #4caf50;
      stroke-width: 1;
    }

    .marker-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 200px;
    }

    @media (max-width: 768px) {
      .header-title {
        flex-direction: column;
        align-items: flex-start;
      }

      .summary-stats {
        flex-wrap: wrap;
      }

      h1 {
        font-size: 2rem;
      }

      .controls-section {
        flex-direction: column;
        align-items: stretch;
      }

      .map-container {
        height: 400px;
        margin: 1rem;
      }

      .table-container {
        margin: 1rem;
      }

      .navigation-links {
        flex-direction: column;
        gap: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <div class="header-title">
        <div class="title-section">
          <img src="https://galaxyproject.org/images/galaxy-logos/galaxy_project_logo_square_no_text_trans.png" alt="Galaxy Project Logo" class="galaxy-logo">
          <div>
            <h1>Galaxy Instance Map</h1>
            <div class="subtitle">Geographic distribution of Galaxy instances worldwide</div>
          </div>
        </div>
        
        <div id="summary-stats" class="summary-stats" style="display: none;">
          <div class="stat-box">
            <div class="stat-number" id="total-servers">0</div>
            <div>Total Instances</div>
          </div>
          <div class="stat-box">
            <div class="stat-number" id="countries-count">0</div>
            <div>Countries</div>
          </div>
          <div class="stat-box">
            <div class="stat-number" id="online-servers">0</div>
            <div>Online</div>
          </div>
        </div>
      </div>
      
      <div class="search-container">
        <input type="text" id="search-input" class="search-input" placeholder="ðŸ” Search instances by name, region, or country...">
      </div>
    </div>

    <div class="controls-section">
      <div class="view-toggle">
        <button id="map-view" class="active">
          <i class="fas fa-map"></i> Map View
        </button>
        <button id="table-view">
          <i class="fas fa-table"></i> Table View
        </button>
      </div>
      
      <button id="refresh-button" class="refresh-btn">
        <i class="fas fa-sync-alt"></i> Refresh Data
      </button>
      
      <button id="export-button" class="export-btn">
        <i class="fas fa-file-csv"></i> Export CSV
      </button>
      
      <button id="geolocate-button" class="refresh-btn">
        <i class="fas fa-map-marked-alt"></i> Refresh Locations
      </button>
    </div>

    <div id="map-container" class="map-container">
      <svg id="world-map"></svg>
    </div>

    <div id="table-container" class="table-container" style="display: none;">
      <div class="table-header">
        <i class="fas fa-globe"></i>
        Galaxy Instances by Location
      </div>
      <div style="overflow-x: auto; max-height: 600px; overflow-y: auto;">
        <table id="location-table">
          <thead>
            <tr>
              <th>Instance</th>
              <th>Tier</th>
              <th>Region</th>
              <th>Location</th>
              <th>Coordinates</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div id="status" class="status-loading">
      Loading Galaxy instance data...
    </div>

    <div class="navigation-links">
      <a href="index.html">
        <i class="fas fa-table"></i> Main Instance Tracker
      </a>
      <a href="https://docs.google.com/spreadsheets/d/1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo/edit#gid=0" target="_blank">
        <i class="fas fa-file-spreadsheet"></i> Source Spreadsheet
      </a>
      <a href="https://github.com/mschatz/gxyservers" target="_blank">
        <i class="fab fa-github"></i> GitHub Repository
      </a>
      <a href="https://gxy.io/kui" target="_blank">
        <i class="fas fa-rocket"></i> Galaxy KUI
      </a>
    </div>
  </div>

  <script>
    // Same Google Sheets configuration as index.html
    const sheetId = '1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo';
    const sheetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;

    // Global variables
    let currentData = [];
    let filteredData = [];
    let currentView = 'map';
    let svg, projection, path, worldData, zoom;

    // D3.js map variables
    const width = 1000;
    const height = 600;

    // Geolocation cache for servers
    const GEO_CACHE_KEY = 'galaxyServerGeoCache';
    const GEO_CACHE_DURATION = 30 * 24 * 60 * 60 * 1000; // 30 days

    // Geolocation functions
    function saveGeoToCache(serverUrl, geoData) {
      try {
        const cache = getGeoCache();
        cache[serverUrl] = {
          data: geoData,
          timestamp: Date.now()
        };
        localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(cache));
      } catch (error) {
        console.log('Error saving geolocation to cache:', error);
      }
    }

    function getGeoFromCache(serverUrl) {
      try {
        const cache = getGeoCache();
        const cached = cache[serverUrl];
        
        if (cached && (Date.now() - cached.timestamp < GEO_CACHE_DURATION)) {
          return cached.data;
        }
        
        // Remove expired cache entry
        if (cached) {
          delete cache[serverUrl];
          localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(cache));
        }
        
        return null;
      } catch (error) {
        console.log('Error reading geolocation from cache:', error);
        return null;
      }
    }

    function getGeoCache() {
      try {
        const cache = localStorage.getItem(GEO_CACHE_KEY);
        return cache ? JSON.parse(cache) : {};
      } catch (error) {
        return {};
      }
    }

    function clearGeoCache() {
      try {
        localStorage.removeItem(GEO_CACHE_KEY);
        console.log('Geolocation cache cleared');
      } catch (error) {
        console.log('Error clearing geolocation cache:', error);
      }
    }

    // Function to get geolocation data for a server URL
    async function getServerGeolocation(url, forceRefresh = false) {
      if (!url || url.trim() === '') {
        return { 
          country: 'Unknown', 
          city: 'Unknown', 
          latitude: null, 
          longitude: null, 
          flag: 'ðŸ³ï¸' 
        };
      }

      // Clean URL for consistency
      let cleanUrl = url.trim();
      if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
        cleanUrl = 'https://' + cleanUrl;
      }

      try {
        const urlObj = new URL(cleanUrl);
        const hostname = urlObj.hostname;

        // Check cache first
        if (!forceRefresh) {
          const cachedData = getGeoFromCache(hostname);
          if (cachedData) {
            return cachedData;
          }
        }

        // Try multiple geolocation APIs
        const geoApis = [
          `https://ipapi.co/${hostname}/json/`,
          `https://api.ipgeolocation.io/ipgeo?apiKey=free&hostname=${hostname}`,
          `https://freegeoip.app/json/${hostname}`
        ];
        
        for (const apiUrl of geoApis) {
          try {
            console.log(`Trying geolocation API for ${hostname}: ${apiUrl}`);
            const response = await fetch(apiUrl);
            
            if (response.ok) {
              const geoData = await response.json();
              console.log(`API response for ${hostname}:`, geoData);
              
              // Handle different API response formats
              let result = null;
              
              // ipapi.co format
              if (geoData && !geoData.error && geoData.country_name) {
                result = {
                  country: geoData.country_name,
                  city: geoData.city || geoData.region || 'Unknown',
                  latitude: parseFloat(geoData.latitude),
                  longitude: parseFloat(geoData.longitude),
                  flag: getCountryFlag(geoData.country_code),
                  countryCode: geoData.country_code
                };
              }
              // ipgeolocation.io format
              else if (geoData && geoData.country_name) {
                result = {
                  country: geoData.country_name,
                  city: geoData.city || geoData.state_prov || 'Unknown',
                  latitude: parseFloat(geoData.latitude),
                  longitude: parseFloat(geoData.longitude),
                  flag: getCountryFlag(geoData.country_code2),
                  countryCode: geoData.country_code2
                };
              }
              // freegeoip.app format
              else if (geoData && geoData.country_name) {
                result = {
                  country: geoData.country_name,
                  city: geoData.city || geoData.region_name || 'Unknown',
                  latitude: parseFloat(geoData.latitude),
                  longitude: parseFloat(geoData.longitude),
                  flag: getCountryFlag(geoData.country_code),
                  countryCode: geoData.country_code
                };
              }
              
              if (result && result.latitude && result.longitude && !isNaN(result.latitude) && !isNaN(result.longitude)) {
                console.log(`Successfully geolocated ${hostname}:`, result);
                saveGeoToCache(hostname, result);
                return result;
              }
            }
          } catch (error) {
            console.log(`Geolocation API ${apiUrl} failed for ${hostname}:`, error);
            continue;
          }
        }

        // All APIs failed, try hostname-based guessing
        console.log(`All geolocation APIs failed for ${hostname}, falling back to hostname patterns`);
        const locationGuess = guessLocationFromHostname(hostname);
        saveGeoToCache(hostname, locationGuess);
        return locationGuess;
        return locationGuess;

      } catch (error) {
        console.log(`Error processing URL ${url}:`, error);
        return { 
          country: 'Unknown', 
          city: 'Unknown', 
          latitude: null, 
          longitude: null, 
          flag: 'ðŸ³ï¸' 
        };
      }
    }

    // Function to guess location from hostname patterns
    function guessLocationFromHostname(hostname) {
      const patterns = {
        '.au': { country: 'Australia', countryCode: 'AU', flag: 'ðŸ‡¦ðŸ‡º', lat: -25.2744, lng: 133.7751 },
        '.uk': { country: 'United Kingdom', countryCode: 'GB', flag: 'ðŸ‡¬ðŸ‡§', lat: 55.3781, lng: -3.4360 },
        '.ca': { country: 'Canada', countryCode: 'CA', flag: 'ðŸ‡¨ðŸ‡¦', lat: 56.1304, lng: -106.3468 },
        '.de': { country: 'Germany', countryCode: 'DE', flag: 'ðŸ‡©ðŸ‡ª', lat: 51.1657, lng: 10.4515 },
        '.fr': { country: 'France', countryCode: 'FR', flag: 'ðŸ‡«ðŸ‡·', lat: 46.2276, lng: 2.2137 },
        '.it': { country: 'Italy', countryCode: 'IT', flag: 'ðŸ‡®ðŸ‡¹', lat: 41.8719, lng: 12.5674 },
        '.es': { country: 'Spain', countryCode: 'ES', flag: 'ðŸ‡ªðŸ‡¸', lat: 40.4637, lng: -3.7492 },
        '.nl': { country: 'Netherlands', countryCode: 'NL', flag: 'ðŸ‡³ðŸ‡±', lat: 52.1326, lng: 5.2913 },
        '.be': { country: 'Belgium', countryCode: 'BE', flag: 'ðŸ‡§ðŸ‡ª', lat: 50.5039, lng: 4.4699 },
        '.se': { country: 'Sweden', countryCode: 'SE', flag: 'ðŸ‡¸ðŸ‡ª', lat: 60.1282, lng: 18.6435 },
        '.no': { country: 'Norway', countryCode: 'NO', flag: 'ðŸ‡³ðŸ‡´', lat: 60.4720, lng: 8.4689 },
        '.dk': { country: 'Denmark', countryCode: 'DK', flag: 'ðŸ‡©ðŸ‡°', lat: 56.2639, lng: 9.5018 },
        '.fi': { country: 'Finland', countryCode: 'FI', flag: 'ðŸ‡«ðŸ‡®', lat: 61.9241, lng: 25.7482 },
        '.ch': { country: 'Switzerland', countryCode: 'CH', flag: 'ðŸ‡¨ðŸ‡­', lat: 46.8182, lng: 8.2275 },
        '.at': { country: 'Austria', countryCode: 'AT', flag: 'ðŸ‡¦ðŸ‡¹', lat: 47.5162, lng: 14.5501 },
        '.cz': { country: 'Czech Republic', countryCode: 'CZ', flag: 'ðŸ‡¨ðŸ‡¿', lat: 49.8175, lng: 15.4730 },
        '.pl': { country: 'Poland', countryCode: 'PL', flag: 'ðŸ‡µðŸ‡±', lat: 51.9194, lng: 19.1451 },
        '.in': { country: 'India', countryCode: 'IN', flag: 'ðŸ‡®ðŸ‡³', lat: 20.5937, lng: 78.9629 },
        '.jp': { country: 'Japan', countryCode: 'JP', flag: 'ðŸ‡¯ðŸ‡µ', lat: 36.2048, lng: 138.2529 },
        '.kr': { country: 'South Korea', countryCode: 'KR', flag: 'ðŸ‡°ðŸ‡·', lat: 35.9078, lng: 127.7669 },
        '.cn': { country: 'China', countryCode: 'CN', flag: 'ðŸ‡¨ðŸ‡³', lat: 35.8617, lng: 104.1954 },
        '.br': { country: 'Brazil', countryCode: 'BR', flag: 'ðŸ‡§ðŸ‡·', lat: -14.2350, lng: -51.9253 },
        '.mx': { country: 'Mexico', countryCode: 'MX', flag: 'ðŸ‡²ðŸ‡½', lat: 23.6345, lng: -102.5528 },
        '.ar': { country: 'Argentina', countryCode: 'AR', flag: 'ðŸ‡¦ðŸ‡·', lat: -38.4161, lng: -63.6167 },
        '.za': { country: 'South Africa', countryCode: 'ZA', flag: 'ðŸ‡¿ðŸ‡¦', lat: -30.5595, lng: 22.9375 },
        '.edu': { country: 'United States', countryCode: 'US', flag: 'ðŸ‡ºðŸ‡¸', lat: 39.8283, lng: -98.5795 },
        '.gov': { country: 'United States', countryCode: 'US', flag: 'ðŸ‡ºðŸ‡¸', lat: 39.8283, lng: -98.5795 },
        '.org': { country: 'United States', countryCode: 'US', flag: 'ðŸ‡ºðŸ‡¸', lat: 39.8283, lng: -98.5795 },
        '.com': { country: 'United States', countryCode: 'US', flag: 'ðŸ‡ºðŸ‡¸', lat: 39.8283, lng: -98.5795 }
      };

      // Check for specific university/institution patterns
      const institutionPatterns = {
        'pasteur.fr': { country: 'France', countryCode: 'FR', flag: 'ðŸ‡«ðŸ‡·', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'inrae.fr': { country: 'France', countryCode: 'FR', flag: 'ðŸ‡«ðŸ‡·', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'uni-freiburg.de': { country: 'Germany', countryCode: 'DE', flag: 'ðŸ‡©ðŸ‡ª', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'usegalaxy.org': { country: 'United States', countryCode: 'US', flag: 'ðŸ‡ºðŸ‡¸', lat: 39.9526, lng: -75.1652, city: 'Pennsylvania' },
        'usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: 'ðŸ‡©ðŸ‡ª', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'usegalaxy.org.au': { country: 'Australia', countryCode: 'AU', flag: 'ðŸ‡¦ðŸ‡º', lat: -37.8136, lng: 144.9631, city: 'Melbourne' },
        'galaxyproject.org': { country: 'United States', countryCode: 'US', flag: 'ðŸ‡ºðŸ‡¸', lat: 39.9526, lng: -75.1652, city: 'Pennsylvania' },
        'genome.edu.au': { country: 'Australia', countryCode: 'AU', flag: 'ðŸ‡¦ðŸ‡º', lat: -37.8136, lng: 144.9631, city: 'Melbourne' }
      };

      // Check for specific institution patterns first
      for (const [pattern, location] of Object.entries(institutionPatterns)) {
        if (hostname.includes(pattern)) {
          return {
            country: location.country,
            city: location.city || 'Unknown',
            latitude: location.lat,
            longitude: location.lng,
            flag: location.flag,
            countryCode: location.countryCode
          };
        }
      }

      // Check TLD patterns
      for (const [tld, location] of Object.entries(patterns)) {
        if (hostname.endsWith(tld)) {
          return {
            country: location.country,
            city: 'Unknown',
            latitude: location.lat,
            longitude: location.lng,
            flag: location.flag,
            countryCode: location.countryCode
          };
        }
      }

      // Default to US for unknown domains
      return {
        country: 'United States',
        city: 'Unknown',
        latitude: 39.8283,
        longitude: -98.5795,
        flag: 'ðŸ‡ºðŸ‡¸',
        countryCode: 'US'
      };
    }

    // Function to get country flag emoji from country code
    function getCountryFlag(countryCode) {
      if (!countryCode || countryCode.length !== 2) return 'ðŸ³ï¸';
      
      const flagMap = {
        'AU': 'ðŸ‡¦ðŸ‡º', 'UK': 'ðŸ‡¬ðŸ‡§', 'GB': 'ðŸ‡¬ðŸ‡§', 'CA': 'ðŸ‡¨ðŸ‡¦', 'DE': 'ðŸ‡©ðŸ‡ª',
        'FR': 'ðŸ‡«ðŸ‡·', 'IT': 'ðŸ‡®ðŸ‡¹', 'ES': 'ðŸ‡ªðŸ‡¸', 'NL': 'ðŸ‡³ðŸ‡±', 'BE': 'ðŸ‡§ðŸ‡ª',
        'SE': 'ðŸ‡¸ðŸ‡ª', 'NO': 'ðŸ‡³ðŸ‡´', 'DK': 'ðŸ‡©ðŸ‡°', 'FI': 'ðŸ‡«ðŸ‡®', 'CH': 'ðŸ‡¨ðŸ‡­',
        'AT': 'ðŸ‡¦ðŸ‡¹', 'CZ': 'ðŸ‡¨ðŸ‡¿', 'PL': 'ðŸ‡µðŸ‡±', 'IN': 'ðŸ‡®ðŸ‡³', 'JP': 'ðŸ‡¯ðŸ‡µ',
        'KR': 'ðŸ‡°ðŸ‡·', 'CN': 'ðŸ‡¨ðŸ‡³', 'BR': 'ðŸ‡§ðŸ‡·', 'MX': 'ðŸ‡²ðŸ‡½', 'AR': 'ðŸ‡¦ðŸ‡·',
        'ZA': 'ðŸ‡¿ðŸ‡¦', 'US': 'ðŸ‡ºðŸ‡¸'
      };
      
      return flagMap[countryCode.toUpperCase()] || 'ðŸ³ï¸';
    }

    // Function to get status icon (full version from index.html)
    function getStatusIcon(version, toolCount, tier = null, serverReachable = null) {
      // Handle null, undefined, or empty version
      if (!version || version === '' || version === null || version === undefined) {
        return { icon: 'â³', class: 'unknown', tooltip: 'Status unknown - loading or no data available' };
      }
      
      // Convert to string and trim for consistent comparison
      const versionStr = String(version).trim();
      const toolCountStr = String(toolCount || '').trim();
      const tierStr = String(tier || '').trim();
      
      // Special handling for Tier 5 (Integrated Deployment) instances
      // For Tier 5, if the site is reachable but API doesn't respond, consider it online
      if (tierStr === '5') {
        // If the instance is reachable (website responds) even with API errors, it's online
        if (serverReachable === true) {
          // Check if we have API errors but the site itself is reachable
          if (versionStr === 'API Error' || versionStr === 'Unknown' || versionStr === 'Error' ||
              versionStr === 'CORS Blocked' || toolCountStr === 'API Error') {
            return { icon: 'ðŸŸ¢', class: 'online', tooltip: 'Integrated platform is online (Galaxy API may not be directly accessible)' };
          }
        }
        
        // If explicitly marked as unreachable or has DNS/network errors, it's offline
        if (versionStr.includes('ERR_NAME_NOT_RESOLVED') || versionStr.includes('ENOTFOUND') || 
            versionStr.includes('SERVER_UNREACHABLE') || versionStr === 'DNS Error' || 
            versionStr === 'Offline') {
          return { icon: 'ðŸ”´', class: 'offline', tooltip: 'Integrated platform is offline or unreachable' };
        }
      }
      
      // Handle specific status values that indicate the instance is completely offline/unreachable
      if (versionStr === 'Offline') {
        return { icon: 'ðŸ”´', class: 'offline', tooltip: 'Instance is offline or unreachable' };
      }
      
      // Check if both version and tools indicate offline/unreachable
      if (toolCountStr === 'Offline' && (versionStr === 'Unknown' || versionStr === 'Error' || versionStr === 'API Error' || versionStr === 'Timeout')) {
        return { icon: 'ðŸ”´', class: 'offline', tooltip: 'Instance is offline or unreachable' };
      }
      
      // Check if both version and tool count show API errors (completely unreachable)
      if (versionStr === 'API Error' && toolCountStr === 'API Error') {
        return { icon: 'ðŸ”´', class: 'offline', tooltip: 'Instance is offline or unreachable (API calls failed)' };
      }
      
      // Check for explicit network/DNS errors that indicate instance is completely offline
      if (versionStr.includes('ERR_NAME_NOT_RESOLVED') || versionStr.includes('ENOTFOUND') || 
          versionStr.includes('SERVER_UNREACHABLE') || versionStr === 'DNS Error') {
        return { icon: 'ðŸ”´', class: 'offline', tooltip: 'Instance is offline or unreachable (DNS/network error)' };
      }
      
      if (versionStr === 'No URL') {
        return { icon: 'âš«', class: 'unknown', tooltip: 'No URL provided for this instance' };
      }
      if (versionStr === 'Local Mode') {
        return { icon: 'ðŸ ', class: 'unknown', tooltip: 'Running in local mode - limited functionality' };
      }
      
      // Handle loading states
      if (versionStr === 'Loading...' || versionStr === 'N/A') {
        return { icon: 'â³', class: 'unknown', tooltip: 'Status unknown or loading...' };
      }
      
      // Check if server is providing data (tools/genomes) even if version is problematic
      const hasToolData = toolCountStr && 
                         toolCountStr !== 'Loading...' && 
                         toolCountStr !== 'N/A' && 
                         toolCountStr !== 'Offline' && 
                         toolCountStr !== 'Error' && 
                         toolCountStr !== 'API Error' && 
                         toolCountStr !== 'Unknown' &&
                         toolCountStr !== 'No URL' &&
                         toolCountStr !== 'Local Mode' &&
                         (toolCountStr.includes('tools') || toolCountStr.includes('genomes') || /^\d+$/.test(toolCountStr));
      
      // If we can fetch tools/genomes but version is unknown, instance is online with issues
      if ((versionStr === 'Unknown' || versionStr === 'API Error' || versionStr === 'Error') && hasToolData) {
        return { icon: 'ðŸŸ¡', class: 'issues', tooltip: 'Instance is online but has API issues (version unknown, but tools/genomes accessible)' };
      }
      
      // CORS blocked but instance appears online
      if (versionStr === 'CORS Blocked') {
        return { icon: 'ðŸŸ¡', class: 'issues', tooltip: 'Instance appears online but API calls are blocked by browser CORS policy' };
      }
      
      // Instance requires authentication but is online
      if (versionStr.includes('Auth Required') || versionStr.includes('Authentication')) {
        return { icon: 'ðŸŸ¡', class: 'issues', tooltip: 'Instance is online but requires authentication for API access' };
      }
      
      // Instance has issues but may be partially accessible (only if no tool data)
      if ((versionStr === 'Unknown' || versionStr === 'API Error' || versionStr === 'Error') && !hasToolData) {
        return { icon: 'ðŸŸ¡', class: 'issues', tooltip: 'Instance status unknown due to API errors' };
      }
      
      // If version contains HTML (like version with start date), check for known patterns
      if (versionStr.includes('<br>') || versionStr.includes('<small>')) {
        // Extract the main version number before any HTML formatting
        const mainVersion = versionStr.split('<br>')[0].split('<small>')[0].trim();
        if (mainVersion && mainVersion !== '' && mainVersion !== 'Unknown' && mainVersion !== 'Error') {
          return { icon: 'ðŸŸ¢', class: 'online', tooltip: 'Instance is online and responding' };
        } else {
          return { icon: 'â“', class: 'unknown', tooltip: 'Instance status uncertain' };
        }
      }
      
      // Default case: if we have a meaningful version string that's not an error, instance is online
      if (versionStr && versionStr !== '' && versionStr !== 'Unknown' && versionStr !== 'Error') {
        return { icon: 'ðŸŸ¢', class: 'online', tooltip: 'Instance is online and responding' };
      }
      
      // Final fallback for any unhandled cases
      return { icon: 'â³', class: 'unknown', tooltip: 'Status unknown' };
    }

    // Function to get tier icon and info
    function getTierInfo(tier) {
      const tierMap = {
        '1': { icon: 'ðŸŒ', name: 'Global Instance', color: '#4caf50' },
        '2': { icon: 'ðŸ›ï¸', name: 'National Instance', color: '#ff9800' },
        '3': { icon: 'ðŸ“', name: 'Subdomain', color: '#2196f3' },
        '4': { icon: 'ðŸ§ª', name: 'Institutional', color: '#9c27b0' },
        '5': { icon: 'ðŸ”—', name: 'Integrated Platform', color: '#607d8b' },
        '6': { icon: 'âš™ï¸', name: 'Development Instance', color: '#795548' }
      };
      
      return tierMap[tier] || { icon: 'â“', name: 'Unknown Tier', color: '#999' };
    }

    // CSV parsing function (same as index.html)
    function parseCSV(text) {
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];
      
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }
      
      const headers = parseCSVLine(lines[0]);
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        
        const hasNonEmptyValue = values.some(value => value && value.trim() !== '');
        if (!hasNonEmptyValue) continue;
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        
        if (row['Tier'] === '###') break;
        if (row['Tier'] && row['Tier'].startsWith('#')) continue;
        
        data.push(row);
      }
      
      return data;
    }

    // Load spreadsheet data
    async function loadSpreadsheetData() {
      updateStatus('Loading Galaxy instance data...', 'loading');
      
      try {
        console.log('Fetching data from:', sheetUrl);
        
        // Add a timeout to the fetch
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
        
        const response = await fetch(sheetUrl, {
          method: 'GET',
          mode: 'cors',
          headers: {
            'Accept': 'text/csv'
          },
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        console.log('Response status:', response.status, response.statusText);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
        }
        
        updateStatus('Processing spreadsheet data...', 'loading');
        const csvText = await response.text();
        console.log('CSV text length:', csvText.length);
        console.log('First 200 chars:', csvText.substring(0, 200));
        
        const data = parseCSV(csvText);
        console.log('Parsed data length:', data.length);
        
        if (data.length === 0) {
          throw new Error('No data found in spreadsheet');
        }
        
        console.log(`Loaded ${data.length} servers from spreadsheet`);
        currentData = data;
        filteredData = [...data];
        
        updateStatus(`Loaded ${data.length} instances. Getting server locations...`, 'loading');
        
        // Get geolocation data for all servers
        await geolocateAllServers();
        
        // Debug: Count how many servers have coordinates
        const serversWithCoords = currentData.filter(row => {
          const geo = row['GeoLocation'];
          return geo && geo.latitude !== null && geo.longitude !== null && 
                 !isNaN(geo.latitude) && !isNaN(geo.longitude);
        }).length;
        
        console.log(`${serversWithCoords} out of ${currentData.length} servers have valid coordinates`);
        
        updateSummaryStats();
        renderCurrentView();
        updateStatus(`Successfully loaded ${data.length} Galaxy instances with location data. ${serversWithCoords} servers mapped.`, 'success');
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        if (error.name === 'AbortError') {
          updateStatus(`Error: Request timed out after 30 seconds`, 'error');
        } else {
          updateStatus(`Error loading data: ${error.message}`, 'error');
        }
        
        // Try to show some fallback data or continue with empty data
        console.log('Continuing with empty data for testing...');
        currentData = [];
        filteredData = [];
        updateSummaryStats();
        renderCurrentView();
      }
    }

    // Geolocate all servers
    async function geolocateAllServers(forceRefresh = false) {
      let completedCount = 0;
      const totalCount = currentData.length;
      
      const promises = currentData.map(async (row, index) => {
        const url = row['URL'] || row['url'] || '';
        
        if (url && url.trim()) {
          try {
            const geoData = await getServerGeolocation(url.trim(), forceRefresh);
            row['GeoLocation'] = geoData;
          } catch (error) {
            console.error(`Error geolocating ${url}:`, error);
            row['GeoLocation'] = { 
              country: 'Unknown', 
              city: 'Unknown', 
              latitude: null, 
              longitude: null, 
              flag: 'ðŸ³ï¸' 
            };
          }
        } else {
          row['GeoLocation'] = { 
            country: 'Unknown', 
            city: 'Unknown', 
            latitude: null, 
            longitude: null, 
            flag: 'ðŸ³ï¸' 
          };
        }
        
        completedCount++;
        if (completedCount % 5 === 0 || completedCount === totalCount) {
          updateStatus(`Getting locations... (${completedCount}/${totalCount} completed)`, 'loading');
        }
      });
      
      await Promise.all(promises);
    }

    // Update status message
    function updateStatus(message, type = 'loading') {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.className = `status-${type}`;
    }

    // Update summary statistics
    function updateSummaryStats() {
      const total = currentData.length;
      const countries = new Set(currentData.map(row => row['GeoLocation']?.country).filter(Boolean)).size;
      const online = currentData.filter(row => {
        const status = getStatusIcon(row['Version'], row['Tool Count'], row['Tier']);
        return status.class === 'online';
      }).length;
      
      document.getElementById('total-servers').textContent = total;
      document.getElementById('countries-count').textContent = countries;
      document.getElementById('online-servers').textContent = online;
      document.getElementById('summary-stats').style.display = 'flex';
    }

    // Render the current view (map or table)
    function renderCurrentView() {
      if (currentView === 'map') {
        document.getElementById('map-container').style.display = 'block';
        document.getElementById('table-container').style.display = 'none';
        
        // Initialize map if first time showing
        if (!svg) {
          initializeMap();
        } else {
          renderMap();
        }
      } else {
        document.getElementById('map-container').style.display = 'none';
        document.getElementById('table-container').style.display = 'block';
        renderTable();
      }
    }

    // Initialize D3 map
    function initializeMap() {
      svg = d3.select("#world-map")
        .attr("width", width)
        .attr("height", height);

      // Set up projection (Natural Earth projection for better world view)
      projection = d3.geoNaturalEarth1()
        .scale(150)
        .translate([width / 2, height / 2]);

      path = d3.geoPath().projection(projection);

      // Add zoom behavior
      zoom = d3.zoom()
        .scaleExtent([0.5, 8])
        .on("zoom", (event) => {
          // Create a group for all map elements if it doesn't exist
          let mapGroup = svg.select(".map-group");
          if (mapGroup.empty()) {
            mapGroup = svg.append("g").attr("class", "map-group");
            // Move all existing elements to the group
            svg.selectAll("path, .map-marker, .marker-cluster, .cluster-text").each(function() {
              mapGroup.node().appendChild(this);
            });
          }
          
          // Apply transform to the entire group
          mapGroup.attr("transform", event.transform);
        });

      svg.call(zoom);

      // Load world data from Natural Earth
      loadWorldData();
    }

    // Load Natural Earth world data
    async function loadWorldData() {
      try {
        updateStatus('Loading world map data...', 'loading');
        
        // Use Natural Earth data via CDN
        const world = await d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
        worldData = world;
        
        // Create or get the map group
        let mapGroup = svg.select(".map-group");
        if (mapGroup.empty()) {
          mapGroup = svg.append("g").attr("class", "map-group");
        }
        
        // Add ocean background first
        mapGroup.insert("path", ":first-child")
          .datum({type: "Sphere"})
          .attr("class", "ocean")
          .attr("d", path);
        
        // Draw countries
        mapGroup.append("g")
          .attr("class", "countries")
          .selectAll("path")
          .data(topojson.feature(world, world.objects.countries).features)
          .enter().append("path")
          .attr("class", "country")
          .attr("d", path)
          .attr("fill", "#e8f5e8")
          .attr("stroke", "#b8d8b8")
          .attr("stroke-width", 0.5);

        console.log('World map loaded successfully');
        
        // Now render the markers if we have data
        if (currentData.length > 0) {
          renderMap();
        }
        
      } catch (error) {
        console.error('Error loading world data:', error);
        updateStatus('Error loading world map. Using fallback...', 'error');
        renderFallbackMap();
        
        // Still try to render markers with fallback map
        if (currentData.length > 0) {
          renderMap();
        }
      }
    }

    // Fallback map if Natural Earth data fails to load
    function renderFallbackMap() {
      // Create or get the map group
      let mapGroup = svg.select(".map-group");
      if (mapGroup.empty()) {
        mapGroup = svg.append("g").attr("class", "map-group");
      }
      
      mapGroup.append("rect")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "#e3f2fd")
        .attr("opacity", 0.3);
        
      // Simple continent outlines as fallback
      const continents = [
        // North America
        "M120,120 L300,100 L350,150 L320,200 L280,220 L200,210 L150,180 Z",
        // South America  
        "M250,250 L320,240 L350,300 L340,380 L300,400 L270,380 L240,320 Z",
        // Europe
        "M450,100 L520,95 L550,130 L530,150 L480,145 Z",
        // Africa
        "M480,180 L550,175 L570,250 L560,320 L520,340 L490,320 L470,250 Z",
        // Asia
        "M550,90 L750,85 L800,140 L780,200 L720,220 L650,200 L580,150 Z",
        // Australia
        "M720,300 L800,295 L820,320 L800,340 L740,335 Z"
      ];
      
      mapGroup.append("g")
        .attr("class", "continents")
        .selectAll("path")
        .data(continents)
        .enter().append("path")
        .attr("d", d => d)
        .attr("fill", "#e8f5e8")
        .attr("stroke", "#b8d8b8")
        .attr("stroke-width", 1);
        
      console.log('Fallback map rendered');
    }

    // Render the map with server markers
    function renderMap() {
      // Initialize map if not already done
      if (!svg) {
        initializeMap();
        return; // Map will be rendered after world data loads
      }
      
      // Get or create the map group
      let mapGroup = svg.select(".map-group");
      if (mapGroup.empty()) {
        mapGroup = svg.append("g").attr("class", "map-group");
      }
      
      // Clear existing markers
      mapGroup.selectAll(".map-marker").remove();
      mapGroup.selectAll(".marker-cluster").remove();
      mapGroup.selectAll(".cluster-text").remove();
      
      let markersAdded = 0;
      
      // Group instances by location (lat/lng with some tolerance for clustering)
      const locationGroups = new Map();
      
      filteredData.forEach((row, index) => {
        const geoData = row['GeoLocation'];
        
        console.log(`Processing server ${row['Name']}: `, geoData);
        
        if (geoData && geoData.latitude !== null && geoData.longitude !== null && 
            !isNaN(geoData.latitude) && !isNaN(geoData.longitude)) {
          
          // Project lat/lng to screen coordinates using D3 projection
          const coords = projection([parseFloat(geoData.longitude), parseFloat(geoData.latitude)]);
          
          if (coords && coords[0] >= 0 && coords[0] <= width && coords[1] >= 0 && coords[1] <= height) {
            // Round coordinates to cluster nearby instances (within ~20px)
            const clusterX = Math.round(coords[0] / 20) * 20;
            const clusterY = Math.round(coords[1] / 20) * 20;
            const clusterKey = `${clusterX},${clusterY}`;
            
            if (!locationGroups.has(clusterKey)) {
              locationGroups.set(clusterKey, {
                x: clusterX,
                y: clusterY,
                instances: [],
                coords: coords // Keep original coords for first instance
              });
            }
            
            locationGroups.get(clusterKey).instances.push({
              ...row,
              originalCoords: coords
            });
          } else {
            console.log(`Invalid coordinates for ${row['Name']}: `, coords);
          }
        } else {
          console.log(`No valid coordinates for ${row['Name']}: `, geoData);
        }
      });
      
      // Create markers for each location group
      locationGroups.forEach((group, key) => {
        const instances = group.instances;
        const coords = [group.x, group.y];
        
        if (instances.length === 1) {
          // Single instance - create regular marker
          const row = instances[0];
          const tier = row['Tier'] || '0';
          
          const singleMarker = mapGroup.append("circle")
            .attr("class", `map-marker tier-${tier}`)
            .attr("cx", coords[0])
            .attr("cy", coords[1])
            .attr("r", 4)
            .attr("fill", getMarkerColorByTier(tier))
            .attr("stroke", "white")
            .attr("stroke-width", 2)
            .style("cursor", "pointer");
          
          // Store timeout references for debouncing
          let singleEnterTimeout = null;
          let singleLeaveTimeout = null;
          
          singleMarker
            .on("mouseenter", function(event) {
              // Clear any pending leave timeout
              if (singleLeaveTimeout) {
                clearTimeout(singleLeaveTimeout);
                singleLeaveTimeout = null;
              }
              
              // Clear any pending enter timeout
              if (singleEnterTimeout) {
                clearTimeout(singleEnterTimeout);
              }
              
              // Set new enter timeout with debouncing
              singleEnterTimeout = setTimeout(() => {
                d3.select(this).transition().duration(200).attr("r", 6);
                showTooltip(event, row);
                singleEnterTimeout = null;
              }, 50);
            })
            .on("mouseleave", function() {
              // Clear any pending enter timeout
              if (singleEnterTimeout) {
                clearTimeout(singleEnterTimeout);
                singleEnterTimeout = null;
              }
              
              // Clear any existing leave timeout
              if (singleLeaveTimeout) {
                clearTimeout(singleLeaveTimeout);
              }
              
              // Set new leave timeout with debouncing
              singleLeaveTimeout = setTimeout(() => {
                d3.select(this).transition().duration(200).attr("r", 4);
                hideTooltip();
                singleLeaveTimeout = null;
              }, 100);
            });
            
          markersAdded++;
        } else {
          // Multiple instances - create clustered marker
          const dominantTier = getMostCommonTier(instances);
          const clusterSize = Math.min(instances.length, 10); // Cap visual size
          const radius = Math.max(6, Math.min(12, 4 + clusterSize));
          
          // Create a group for the cluster to handle events properly
          const clusterGroup = mapGroup.append("g")
            .attr("class", "cluster-group")
            .style("cursor", "pointer");
          
          // Store a reference for debouncing
          let enterTimeout = null;
          let leaveTimeout = null;
          
          clusterGroup
            .on("mouseenter", function(event) {
              // Clear any pending leave timeout
              if (leaveTimeout) {
                clearTimeout(leaveTimeout);
                leaveTimeout = null;
              }
              
              // Clear any pending enter timeout
              if (enterTimeout) {
                clearTimeout(enterTimeout);
              }
              
              // Set new enter timeout with debouncing
              enterTimeout = setTimeout(() => {
                d3.select(this).select(".marker-cluster")
                  .transition().duration(200).attr("r", radius + 2);
                
                if (instances.length === 1) {
                  showTooltip(event, instances[0]);
                } else {
                  showClusterTooltip(event, instances);
                }
                enterTimeout = null;
              }, 50);
            })
            .on("mouseleave", function() {
              // Clear any pending enter timeout
              if (enterTimeout) {
                clearTimeout(enterTimeout);
                enterTimeout = null;
              }
              
              // Clear any existing leave timeout
              if (leaveTimeout) {
                clearTimeout(leaveTimeout);
              }
              
              // Set new leave timeout with debouncing
              leaveTimeout = setTimeout(() => {
                d3.select(this).select(".marker-cluster")
                  .transition().duration(200).attr("r", radius);
                hideTooltip();
                leaveTimeout = null;
              }, 100);
            });
          
          // Create cluster background circle
          clusterGroup.append("circle")
            .attr("class", `marker-cluster cluster-tier-${dominantTier}`)
            .attr("cx", coords[0])
            .attr("cy", coords[1])
            .attr("r", radius)
            .attr("fill", getMarkerColorByTier(dominantTier))
            .attr("stroke", "white")
            .attr("stroke-width", 3)
            .attr("opacity", 0.8);
          
          // Add count text on cluster - make it non-interactive
          clusterGroup.append("text")
            .attr("class", "cluster-text")
            .attr("x", coords[0])
            .attr("y", coords[1])
            .attr("dy", "0.35em")
            .attr("text-anchor", "middle")
            .attr("fill", "white")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("pointer-events", "none")
            .style("user-select", "none")
            .text(instances.length);
            
          markersAdded += instances.length;
        }
      });
      
      console.log(`Total markers added to map: ${markersAdded} out of ${filteredData.length} servers in ${locationGroups.size} location groups`);
      
      // Add a legend
      addMapLegend();
    }
    
    // Helper function to find the most common tier in a group
    function getMostCommonTier(instances) {
      const tierCounts = {};
      instances.forEach(instance => {
        const tier = instance['Tier'] || '0';
        tierCounts[tier] = (tierCounts[tier] || 0) + 1;
      });
      
      return Object.keys(tierCounts).reduce((a, b) => 
        tierCounts[a] > tierCounts[b] ? a : b
      );
    }
    
    // Helper function to get marker color by tier
    function getMarkerColorByTier(tier) {
      const tierColors = {
        '1': '#4caf50',    // Global Instance - Green
        '2': '#ff9800',    // National Instance - Orange  
        '3': '#2196f3',    // Subdomain - Blue
        '4': '#9c27b0',    // Institutional - Purple
        '5': '#607d8b',    // Integrated Platform - Blue Grey
        '6': '#795548'     // Development Instance - Brown
      };
      return tierColors[tier] || '#999'; // Default grey for unknown tiers
    }

    // Helper function to get marker color by status (keeping for reference)
    function getMarkerColorByStatus(statusClass) {
      const colors = {
        'online': '#4caf50',
        'issues': '#ff9800', 
        'offline': '#f44336',
        'unknown': '#999'
      };
      return colors[statusClass] || '#999';
    }
    
    // Add legend to the map
    function addMapLegend() {
      const mapContainer = document.getElementById('map-container');
      
      // Remove existing legend
      const existingLegend = mapContainer.querySelector('.map-legend');
      if (existingLegend) {
        existingLegend.remove();
      }
      
      const legend = document.createElement('div');
      legend.className = 'map-legend';
      legend.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        font-size: 12px;
        z-index: 100;
      `;
      
      legend.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 5px;">Instance Tiers</div>
        <div style="margin: 3px 0;"><span style="color: #4caf50;">â—</span> Global Instance</div>
        <div style="margin: 3px 0;"><span style="color: #ff9800;">â—</span> National Instance</div>
        <div style="margin: 3px 0;"><span style="color: #2196f3;">â—</span> Subdomain</div>
        <div style="margin: 3px 0;"><span style="color: #9c27b0;">â—</span> Institutional</div>
        <div style="margin: 3px 0;"><span style="color: #607d8b;">â—</span> Integrated Platform</div>
        <div style="margin: 3px 0;"><span style="color: #795548;">â—</span> Development Instance</div>
        <div style="margin-top: 8px; font-size: 11px; color: #666; font-style: italic;">
          Numbers show multiple instances<br>at the same location
        </div>
      `;
      
      mapContainer.appendChild(legend);
    }

    // Show tooltip for clustered markers
    function showClusterTooltip(event, instances) {
      // Remove any existing tooltips first
      hideTooltip();
      
      // Small delay to prevent rapid tooltip creation/destruction
      setTimeout(() => {
        const tooltip = document.createElement('div');
        tooltip.className = 'marker-tooltip cluster-tooltip';
        tooltip.style.cssText = `
          position: fixed;
          left: ${event.clientX + 10}px;
          top: ${event.clientY - 10}px;
          background: rgba(0, 0, 0, 0.9);
          color: white;
          padding: 0.75rem;
          border-radius: 6px;
          font-size: 0.8rem;
          pointer-events: none;
          z-index: 10000;
          max-width: 300px;
          max-height: 400px;
          overflow-y: auto;
          border: 1px solid #444;
        `;
        
        // Get location info from first instance
        const geoData = instances[0]['GeoLocation'];
        
        // Group instances by tier for summary
        const tierGroups = {};
        const statusGroups = { online: 0, issues: 0, offline: 0, unknown: 0 };
        
        instances.forEach(instance => {
          const tier = instance['Tier'] || '0';
          const tierInfo = getTierInfo(tier);
          if (!tierGroups[tier]) {
            tierGroups[tier] = { name: tierInfo.name, icon: tierInfo.icon, instances: [] };
          }
          tierGroups[tier].instances.push(instance);
          
          // Count status
          const status = getStatusIcon(instance['Version'], instance['Tool Count'], instance['Tier']);
          statusGroups[status.class] = (statusGroups[status.class] || 0) + 1;
        });
        
        let content = `
          <div style="font-weight: bold; margin-bottom: 0.5rem;">
            ${geoData.flag} ${geoData.city}, ${geoData.country}
          </div>
          <div style="margin-bottom: 0.5rem; color: #ccc;">
            ${instances.length} Galaxy Instance${instances.length > 1 ? 's' : ''}
          </div>
        `;
        
        // Add tier breakdown
        Object.keys(tierGroups).forEach(tier => {
          const group = tierGroups[tier];
          content += `
            <div style="margin: 0.25rem 0; font-size: 0.75rem;">
              ${group.icon} ${group.name}: ${group.instances.length}
            </div>
          `;
        });
        
        // Add status summary
        const statusIcons = { online: 'ðŸŸ¢', issues: 'ðŸŸ¡', offline: 'ðŸ”´', unknown: 'â³' };
        content += '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #666; font-size: 0.75rem;">';
        Object.keys(statusGroups).forEach(status => {
          if (statusGroups[status] > 0) {
            content += `<span style="margin-right: 0.5rem;">${statusIcons[status]} ${statusGroups[status]}</span>`;
          }
        });
        content += '</div>';
        
        // Add individual instances (limit to first 10 to avoid overwhelming)
        if (instances.length <= 10) {
          content += '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #666;">';
          instances.forEach(instance => {
            const status = getStatusIcon(instance['Version'], instance['Tool Count'], instance['Tier']);
            const tierInfo = getTierInfo(instance['Tier']);
            content += `
              <div style="margin: 0.25rem 0; font-size: 0.7rem; color: #ddd;">
                ${status.icon} ${tierInfo.icon} ${instance['Name'] || 'Unknown'}
              </div>
            `;
          });
          content += '</div>';
        } else {
          content += `<div style="margin-top: 0.5rem; font-size: 0.7rem; color: #aaa; font-style: italic;">
            Click to view all ${instances.length} instances in table
          </div>`;
        }
        
        tooltip.innerHTML = content;
        document.body.appendChild(tooltip);
        
        // Store reference for cleanup
        tooltip.setAttribute('data-tooltip-id', 'cluster-tooltip');
      }, 50);
    }

    // Show tooltip for map markers
    function showTooltip(event, row) {
      // Remove any existing tooltips first
      hideTooltip();
      
      // Small delay to prevent rapid tooltip creation/destruction
      setTimeout(() => {
        const tooltip = document.createElement('div');
        tooltip.className = 'marker-tooltip';
        tooltip.style.cssText = `
          position: fixed;
          left: ${event.clientX + 10}px;
          top: ${event.clientY - 10}px;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 0.5rem;
          border-radius: 4px;
          font-size: 0.8rem;
          pointer-events: none;
          z-index: 10000;
          max-width: 200px;
        `;
        
        const geoData = row['GeoLocation'];
        const status = getStatusIcon(row['Version'], row['Tool Count'], row['Tier']);
        const tierInfo = getTierInfo(row['Tier']);
        
        tooltip.innerHTML = `
          <strong>${row['Name'] || 'Unknown'}</strong><br>
          ${geoData.flag} ${geoData.city}, ${geoData.country}<br>
          ${tierInfo.icon} ${tierInfo.name}<br>
          ${status.icon} ${status.tooltip}
        `;
        
        document.body.appendChild(tooltip);
        
        // Store reference for cleanup
        tooltip.setAttribute('data-tooltip-id', 'single-tooltip');
      }, 50);
    }

    // Hide tooltip
    function hideTooltip() {
      const tooltips = document.querySelectorAll('.marker-tooltip');
      tooltips.forEach(tooltip => {
        if (tooltip.parentNode) {
          tooltip.parentNode.removeChild(tooltip);
        }
      });
    }

    // Render the location table
    function renderTable() {
      const tbody = document.querySelector('#location-table tbody');
      tbody.innerHTML = '';
      
      if (filteredData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="no-results">No instances match your search criteria.</td></tr>';
        return;
      }
      
      filteredData.forEach(row => {
        const tr = document.createElement('tr');
        
        const geoData = row['GeoLocation'] || {};
        const status = getStatusIcon(row['Version'], row['Tool Count'], row['Tier']);
        const tierInfo = getTierInfo(row['Tier']);
        
        tr.innerHTML = `
          <td>
            <div class="server-name">${row['Name'] || 'Unknown'}</div>
            ${row['URL'] ? `<a href="${row['URL']}" target="_blank" class="server-url">${row['URL']}</a>` : ''}
          </td>
          <td>
            <span class="tier-icon" style="color: ${tierInfo.color}">${tierInfo.icon}</span>
            ${tierInfo.name}
          </td>
          <td>${row['Region'] || 'Unknown'}</td>
          <td>
            <div class="location-info">
              <div>
                <span class="country-flag">${geoData.flag || 'ðŸ³ï¸'}</span>
                ${geoData.city || 'Unknown'}, ${geoData.country || 'Unknown'}
              </div>
            </div>
          </td>
          <td>
            ${geoData.latitude && geoData.longitude ? 
              `<div class="coordinates">${geoData.latitude.toFixed(4)}, ${geoData.longitude.toFixed(4)}</div>` : 
              '<span style="color: #999;">Unknown</span>'
            }
          </td>
        `;
        
        tbody.appendChild(tr);
      });
    }

    // Search and filter functionality
    function performFilter() {
      const searchTerm = document.getElementById('search-input').value.toLowerCase().trim();
      
      if (searchTerm === '') {
        filteredData = [...currentData];
      } else {
        filteredData = currentData.filter(row => {
          const geoData = row['GeoLocation'] || {};
          return (
            (row['Name'] || '').toLowerCase().includes(searchTerm) ||
            (row['Region'] || '').toLowerCase().includes(searchTerm) ||
            (row['URL'] || '').toLowerCase().includes(searchTerm) ||
            (geoData.country || '').toLowerCase().includes(searchTerm) ||
            (geoData.city || '').toLowerCase().includes(searchTerm)
          );
        });
      }
      
      renderCurrentView();
      updateSummaryStats();
    }

    // Export to CSV
    function exportToCSV() {
      if (!filteredData || filteredData.length === 0) {
        alert('No data to export.');
        return;
      }
      
      const headers = ['Name', 'URL', 'Region', 'Tier', 'Country', 'City', 'Latitude', 'Longitude', 'Version', 'Tool Count'];
      const csvRows = [headers.join(',')];
      
      filteredData.forEach(row => {
        const geoData = row['GeoLocation'] || {};
        const csvRow = [
          `"${(row['Name'] || '').replace(/"/g, '""')}"`,
          `"${(row['URL'] || '').replace(/"/g, '""')}"`,
          `"${(row['Region'] || '').replace(/"/g, '""')}"`,
          `"${(row['Tier'] || '').replace(/"/g, '""')}"`,
          `"${(geoData.country || '').replace(/"/g, '""')}"`,
          `"${(geoData.city || '').replace(/"/g, '""')}"`,
          geoData.latitude || '',
          geoData.longitude || '',
          `"${(row['Version'] || '').replace(/"/g, '""')}"`,
          `"${(row['Tool Count'] || '').replace(/"/g, '""')}"`
        ];
        csvRows.push(csvRow.join(','));
      });
      
      const csvContent = csvRows.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      const now = new Date();
      const timestamp = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0') + '_' +
        String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      
      a.download = `galaxy_instances_map_${timestamp}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Initialize the application
    function initializeApp() {
      // View toggle functionality
      document.getElementById('map-view').addEventListener('click', () => {
        currentView = 'map';
        document.getElementById('map-view').classList.add('active');
        document.getElementById('table-view').classList.remove('active');
        renderCurrentView();
      });
      
      document.getElementById('table-view').addEventListener('click', () => {
        currentView = 'table';
        document.getElementById('table-view').classList.add('active');
        document.getElementById('map-view').classList.remove('active');
        renderCurrentView();
      });
      
      // Search functionality
      document.getElementById('search-input').addEventListener('input', performFilter);
      
      // Button functionality
      document.getElementById('refresh-button').addEventListener('click', () => {
        location.reload();
      });
      
      document.getElementById('export-button').addEventListener('click', exportToCSV);
      
      document.getElementById('geolocate-button').addEventListener('click', async () => {
        const button = document.getElementById('geolocate-button');
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        button.disabled = true;
        
        updateStatus('Refreshing location data...', 'loading');
        clearGeoCache();
        await geolocateAllServers(true);
        
        renderCurrentView();
        updateSummaryStats();
        updateStatus('Location data refreshed successfully.', 'success');
        
        button.innerHTML = '<i class="fas fa-map-marked-alt"></i> Refresh Locations';
        button.disabled = false;
      });
      
      // Load initial data
      loadSpreadsheetData();
    }

    // Start the application when DOM is loaded
    document.addEventListener('DOMContentLoaded', initializeApp);
  </script>
</body>
</html>
